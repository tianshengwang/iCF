######################################################################################################----------------------------------------------
######################################################################################################----------------------------------------------
########                      III. prepare subpopulation-based majority vote. PART II.
######################################################################################################----------------------------------------------
###################################################s###################################################-----------------------------------------------

#library(tidyverse)
#' @param PRE_Node The Y values
#source("/local/projects/medicare/DPP4i_HTE/programs/macros/PRE_MAJORITY.R")
#----------------------------------------------
# I. prepare tree-based majority vote:  
#----------------------------------------------
#remove unnecessary columns in each datafram showing No. of nodes in the LIST
PRE_MAJORITY_TREE <- function(besttreeLIST){
  #list0<-lapply(LIST, function(df) cbind(df, No_nodes =nrow(df)) ) #add a new column in each datafram showing No. of nodes in the LIST, not necessary
  list1<-lapply(besttreeLIST, function(df) subset(df, select=-c(7:11 #remove samples, avg_Y, avg_W, k/b, HTE_P_cf #k=iteraction #
  )))
  return(list1)
}
#----------------2C01851D|--------------------------------------------------------------
# II. prepare relaxed tree-based majority vote:  (dont' care split value) 
#------------------------------------------------------------------------------
#remove unnecessary columns in each datafram showing No. of nodes in the LIST
PRE_MAJORITY_TREE_R <- function(besttreeLIST){
  list1<-lapply(besttreeLIST, function(df) subset(df, select=-c(6:11 #remove split_value, samples, avg_Y, avg_W, k/b, split_value, HTE_P_cf
                                                                )))
  return(list1)
}


#lab start
#tree_original <-  list(IT_btree_df)
#lab over

PRE_MAJORITY_SUBGROUP <- function(tree_original){
  #as designed (by min node size) "depth=4" tree may still be depth=3 when the truth is 3-way interaction, 
  #we need to identify real tree shape generated by "depth=4" min node size

    parent_1 <- PARENT_NODES (tree_original, tree_original,1)
    parent_2 <- PARENT_NODES (tree_original, parent_1,     2)
    parent_3 <- PARENT_NODES (tree_original, parent_2,     3)
    parent_4 <- PARENT_NODES (tree_original, parent_3,     4)
    parent_5 <- PARENT_NODES (tree_original, parent_4,     5)
    parent_6 <- PARENT_NODES (tree_original, parent_5,     6)
    parent_7 <- PARENT_NODES (tree_original, parent_6,     7)
    parent_8 <- PARENT_NODES (tree_original, parent_7,     8)
    parent_9 <- PARENT_NODES (tree_original, parent_8,     9)
    parent_10 <- PARENT_NODES (tree_original, parent_9,     10)
    parent_11 <- PARENT_NODES (tree_original, parent_10,     11)
    parent_12 <- PARENT_NODES (tree_original, parent_11,     12)
    parent_13 <- PARENT_NODES (tree_original, parent_12,     13)
    parent_14 <- PARENT_NODES (tree_original, parent_13,     14)
    parent_15 <- PARENT_NODES (tree_original, parent_14,     15)
    parent_16 <- PARENT_NODES (tree_original, parent_15,     16)
    parent_17 <- PARENT_NODES (tree_original, parent_16,     17)
    parent_18 <- PARENT_NODES (tree_original, parent_17,     18)
    parent_19 <- PARENT_NODES (tree_original, parent_18,     19)
    parent_20 <- PARENT_NODES (tree_original, parent_19,     20)
    
  # 10/30/2022 I haven't figured out how to do it in a loop like below to run only necessary iteration to a max of nrow(tree_original) times, 
    #but since it's not computationally expensive, I'll just manually write 20 lines of codes
  #  for (nr in 1: nrow(tree_original) ){
  #    if (nr==1) {
  #      parent_1 <- PARENT_NODES (tree_original, tree_original,1)
  #    } else {
  #      eval( parse(paste0("parent_",nr)) )  <- PARENT_NODES (tree_original,     eval( parse(paste0("parent_",nr-1 )) ) , nr)
  #    }
  #  }
    

   
    
    #combine parent_split_var, parent_sign, and parent_split_val
    
subgroup_0 <- lapply( parent_20, 
                     function(df) df %>% dplyr::select (tidyselect::starts_with( c("LEAF", "condition_", "parent_split_var_", "parent_sign_", "parent_split_val_" ) ) ))	
    

#keep dynamic number of conditons, i.e.. conditon_1 (e.g. x4>1), condition_2 (x4<=0.7), ... condition_i ... for subsetting later
subgroup_1 <- lapply(subgroup_0, 
                     function(df) 
                     df %>% mutate (subgroup_dup = do.call(paste, c( df[  colnames(df[2:(1 + as.numeric( stringr::str_sub(colnames(df[2]),-1,-1) )  ) ]) ] , sep = " "  )) ) 
                     )
#remove duplicate conditions in the subgroup column, sapply nested in lapply, super cool!!!
subgroup_2 <- lapply(subgroup_1, 
                     function(df) 
                     df %>% mutate (subgroup = sapply(df$subgroup_dup, function(x) paste(unique(unlist(stringr::str_split(x," "))), collapse = " ")) )
                     )

  #--------------------------------------------------------------------------------------------------------
  # the folloing 3 key step to order cell of 1) subgroup condition, 2) subgroup name, and 3) subgroup ID
  # after ranking, subgroupID (order) doesn't reflecct tree grows (i.e. how patients are grouped) anymore, but ordering is necessary for majority vote to remove duplicate subgroups
  #--------------------------------------------------------------------------------------------------------
  #1) order each sugbgroup cell (label) in the subgroup column by alphabetically:
  #i.e. each cell from "X8<=0 X1<=0 X3<=0" to "X8<=0, X3<=0, X1<=0"
  subgroup1_sort_cell <- lapply(subgroup_2, function(df)  df %>% rowwise() %>% mutate(subgroup = paste(sort(unlist(strsplit(subgroup, " ", fixed = TRUE)), decreasing = TRUE), collapse = " & ")))  
  
  #2) sort dataframe by subgroup name alphabetically
  subgroup1_sort_group <- lapply(subgroup1_sort_cell, function(df) df[order(df$subgroup),])
  
  #3) add NEW subgroup ID using rown name order
  subgroup <- lapply(subgroup1_sort_group, function(df) tibble::rowid_to_column(df, "subgroupID") )

  
  return (subgroup)
}